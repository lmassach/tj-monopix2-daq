#!/usr/bin/env python3
"""Plots the results of multiple scan_threshold from the .npz files produced by plot_scurve_pisa.py."""
import argparse
import glob
from itertools import chain
import os
import traceback
from matplotlib.backends.backend_pdf import PdfPages
import matplotlib.cm
import matplotlib.pyplot as plt
import numpy as np
import tables as tb
from tqdm import tqdm
from uncertainties import ufloat
from plot_utils_pisa import *

VIRIDIS_WHITE_UNDER = matplotlib.cm.get_cmap('viridis').copy()
VIRIDIS_WHITE_UNDER.set_under('w')


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("output_file", help="The output PDF.")
    parser.add_argument("input_file", nargs="+",
                        help="The _threshold_scan_interpreted_scurve.npz file(s).")
    args = parser.parse_args()

    files = []
    if args.input_file:  # If anything was given on the command line
        for pattern in args.input_file:
            files.extend(glob.glob(pattern, recursive=True))
    else:
        files.extend(glob.glob("output_data/module_0/chip_0/*_threshold_scan_interpreted.h5"))
    files.sort()

    # Load results from NPZ files
    thresholds = np.full((512, 512), np.nan)
    noise = np.full((512, 512), np.nan)
    for fp in tqdm(files, unit="file"):
        with np.load(fp) as data:
            overwritten = (~np.isnan(thresholds)) & (~np.isnan(data['thresholds']))
            n_overwritten = np.count_nonzero(overwritten)
            if n_overwritten:
                print("WARNING Multiple values of threshold for the same pixel(s)")
                print(f"    count={n_overwritten}, file={fp}")
            thresholds = np.where(np.isnan(thresholds), data['thresholds'], thresholds)

            overwritten = (~np.isnan(noise)) & (~np.isnan(data['noise']))
            n_overwritten = np.count_nonzero(overwritten)
            if n_overwritten:
                print("WARNING Multiple values of threshold for the same pixel(s)")
                print(f"    count={n_overwritten}, file={fp}")
            noise = np.where(np.isnan(noise), data['noise'], noise)

    # Do the plotting
    with PdfPages(args.output_file) as pdf:
        plt.figure(figsize=(6.4, 4.8))

        plt.annotate(
            split_long_text(
                "This file was generated by joining the following\n\n"
                + "\n".join(files)
                ), (0.5, 0.5), ha='center', va='center')
        plt.gca().set_axis_off()
        pdf.savefig(); plt.clf()

        # Threshold hist
        good_thr_msk = np.isfinite(thresholds) & (thresholds != 0)
        # m1, m2 = np.quantile(thresholds[good_thr_msk], [0.05, 0.95])
        # m1, m2 = max(0.1, m1 - 2), m2 + 2
        m1, m2 = 18, 31
        for i, (fc, lc, name) in enumerate(FRONTENDS):
            gtm = good_thr_msk[fc:lc+1,:]
            if not np.any(gtm):
                continue
            th = thresholds[fc:lc+1,:]
            th_mean = ufloat(np.mean(th[gtm]), np.std(th[gtm], ddof=1))
            plt.hist(th.reshape(-1) * 10, bins=100, range=[m1*10, m2*10],
                     label=f"{name} ${th_mean*10:L}$", histtype='step', color=f"C{i}")
        plt.suptitle("Threshold distribution")
        plt.xlabel("Threshold [$e^-$]")
        plt.ylabel("Pixels / bin")
        set_integer_ticks(plt.gca().yaxis)
        plt.legend()
        plt.grid(axis='y')
        pdf.savefig(); plt.clf()

        # Threshold map
        plt.axes((0.125, 0.11, 0.775, 0.72))
        edges = np.linspace(0, 512, 513, endpoint=True)
        plt.pcolormesh(edges, edges, thresholds.transpose() * 10, vmin=m1*10, vmax=m2*10,
                       rasterized=True)  # Necessary for quick save and view in PDF
        plt.suptitle("Threshold map")
        plt.xlabel("Column")
        plt.ylabel("Row")
        set_integer_ticks(plt.gca().xaxis, plt.gca().yaxis)
        cb = plt.colorbar()
        cb.set_label("Threshold [$e^-$]")
        frontend_names_on_top()
        pdf.savefig(); plt.clf()

        # Noise hist
        good_noise_msk = np.isfinite(noise) & (noise != 0)
        # m1, m2 = np.quantile(noise[good_noise_msk], [0.05, 0.95])
        # m1, m2 = max(0.01, m1 - 0.2), m2 + 0.2
        m1, m2 = 0.3, 1.2
        for i, (fc, lc, name) in enumerate(FRONTENDS):
            gnm = good_noise_msk[fc:lc+1,:]
            if not np.any(gnm):
                continue
            ns = noise[fc:lc+1,:]
            noise_mean = ufloat(np.mean(ns[gnm]), np.std(ns[gnm], ddof=1))
            plt.hist(ns.reshape(-1) * 10, bins=100, range=[m1*10, m2*10],
                     label=f"{name} ${noise_mean*10:L}$", histtype='step', color=f"C{i}")
        plt.suptitle(f"Noise (ENC) distribution")
        plt.xlabel("Noise (ENC) [$e^-$]")
        plt.ylabel("Pixels / bin")
        set_integer_ticks(plt.gca().yaxis)
        plt.grid(axis='y')
        plt.legend()
        pdf.savefig(); plt.clf()

        # Noise map
        plt.axes((0.125, 0.11, 0.775, 0.72))
        plt.pcolormesh(edges, edges, noise.transpose() * 10, vmin=m1*10, vmax=m2*10,
                       rasterized=True)  # Necessary for quick save and view in PDF
        plt.suptitle("Noise (width of s-curve slope) map")
        plt.xlabel("Column")
        plt.ylabel("Row")
        set_integer_ticks(plt.gca().xaxis, plt.gca().yaxis)
        cb = plt.colorbar()
        cb.set_label("Noise (ENC) [$e^-$]")
        frontend_names_on_top()
        pdf.savefig(); plt.clf()
