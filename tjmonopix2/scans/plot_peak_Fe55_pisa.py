#!/usr/bin/env python3
"""Fit to the Fe55 ToT peak."""
import argparse
import glob
from itertools import chain, product
import os
import traceback
from matplotlib.backends.backend_pdf import PdfPages
import matplotlib.pyplot as plt
import numpy as np
from scipy.optimize import curve_fit
import tables as tb
from tqdm import tqdm
from uncertainties import ufloat
from plot_utils_pisa import *

MIN_TOT_CUT = 0


def gaus(x, mu, sigma):
    """Gaussian normalized with peak height = 1."""
    return np.exp(-0.5 * ((x - mu) / sigma)**2)


def shoulder(x, center, width):
    """A shoulder of height 1."""
    xi = (x - center) / width
    return np.sqrt(np.maximum(0, 1 - xi*xi))


def fit_func(x, mu, sigma, h_sig, center, width, h_bkg):
    """Gaussian + constant for x < mu, zero for x > mu."""
    return h_sig * gaus(x, mu, sigma) + h_bkg * shoulder(x, center, width)


def main(input_files, overwrite=False, pixels=(0, -1, 0, -1), output_file=None):
    if output_file is None:
        output_file = os.path.splitext(input_files[0])[0] + "_Fe55.pdf"
    if os.path.isfile(output_file) and not overwrite:
        return

    # Prepare histogram
    counts = np.zeros((512, 512, 128))
    cfg = []

    for input_file in tqdm(input_files, disable=len(input_files)<2):
        print("Processing", input_file)
        with tb.open_file(input_file) as f:
            cfg.append(get_config_dict(f))

            # Process 16M hits at a time
            csz = 2**24
            n_hits = f.root.Dut.shape[0]
            for i_first in tqdm(range(0, n_hits, csz), unit="chunk", disable=n_hits/csz<=1):
                i_last = min(i_first + csz, n_hits)
                hits = f.root.Dut[i_first:i_last]
                # TODO Filter only isolated hits?
                with np.errstate(all='ignore'):
                    tmp, edges = np.histogramdd(
                        (hits["col"], hits["row"], (hits["te"] - hits["le"]) & 0x7f),
                        bins=[512, 512, 128], range=[[0, 512], [0, 512], [0, 128]])
                    counts += tmp
                    del tmp
            del hits

    with PdfPages(output_file) as pdf, np.errstate(all='ignore'):
        plt.figure(figsize=(6.4, 4.8))

        if len(input_files) > 1:
            plt.annotate(
                split_long_text(
                    "This file was generated by joining the following\n\n"
                    + "\n".join(input_files)
                    ), (0.5, 0.5), ha='center', va='center')
            plt.gca().set_axis_off()
            pdf.savefig(); plt.clf()

        for input_file, c in zip(input_files, cfg):
            draw_summary(input_file, c)
            pdf.savefig(); plt.clf()
        # print("Summary")

        # Fit the peak
        col_first, col_last, row_first, row_last = pixels
        x = np.arange(0, 128)
        x_cut = np.arange(MIN_TOT_CUT, 128)
        mus = np.full((512, 512), np.nan)
        sigmas = np.full((512, 512), np.nan)
        n_pix = 1 + max(0, (col_last + 1 - col_first) * (row_last + 1 - row_first))
        n_failed_fit = 0
        for i, (col, row) in tqdm(
            enumerate(chain(((None, None),), product(range(col_first, col_last+1), range(row_first, row_last+1)))),
            unit="pixel", disable=n_pix<250, total=n_pix):
            if col is None:
                tot = counts.sum(axis=(0, 1))
            else:
                tot = counts[col,row,:]
            tot_cut = tot[MIN_TOT_CUT:]
            try:
                peak_pos = np.argmax(tot_cut)
                p0 = (peak_pos, 0.5, np.max(tot_cut), 14, 12, tot_cut[peak_pos-10:peak_pos-6].mean())
                popt, pcov = curve_fit(fit_func, x_cut, tot_cut, p0=p0)
            except Exception:
                popt = np.full(6, np.nan)
                pcov = np.full((6, 6), np.nan)
                n_failed_fit += 1
            pstd = np.sqrt(pcov.diagonal())
            if col is None or i % 8192 == 1 or (np.isnan(popt[0]) and n_failed_fit < 5):
                plt.step(x, tot, where='mid', lw=2, label='Data')
                if np.isnan(popt[0]):
                    fit_res = [
                        f"${n}={m:.3g}$"
                        for m, n in zip(p0, ["\\mu", "\\sigma", "h_{sig}", "c", "w", "h_{bkg}"])]
                    plt.plot(x, fit_func(x, *p0), label='Initial fit parameters')
                    plt.plot(x, p0[2] * gaus(x, *p0[:2]), '--', label='Gaussian peak\n' + "\n".join(fit_res[:3]))
                    plt.plot(x, p0[5] * shoulder(x, *p0[3:5]), '--', label='Background\n' + "\n".join(fit_res[3:]))
                else:
                    fit_res = [
                        f"${n}={ufloat(m,s):L}$"
                        for m, s, n in zip(popt, pstd, ["\\mu", "\\sigma", "h_{sig}", "c", "w", "h_{bkg}"])]
                    plt.plot(x, fit_func(x, *popt), label='Total fit')
                    plt.plot(x, popt[2] * gaus(x, *popt[:2]), '--', label='Gaussian peak\n' + "\n".join(fit_res[:3]))
                    plt.plot(x, popt[5] * shoulder(x, *popt[3:5]), '--', label='Background\n' + "\n".join(fit_res[3:]))
                the_pixel = "all pixels" if col is None else str((col, row))
                plt.title(f"{the_pixel} spectrum (fit failed)" if np.isnan(popt[0]) else f"Fit to {the_pixel}")
                plt.xlabel("ToT [25 ns]")
                plt.ylabel("Counts / bin")
                plt.legend()
                pdf.savefig(); plt.clf()
            if col is not None:
                mus[col,row] = popt[0]
                sigmas[col,row] = popt[1]

        # Peak mu distribution
        for fc, lc, name in FRONTENDS:
            plt.hist(mus[fc:lc+1,:].reshape(-1), bins=128, range=[0, 128],
                     histtype='step', label=name, rasterized=True)
        plt.xlabel("Peak $\\mu$ [25 ns]")
        plt.ylabel("Pixels / bin")
        plt.suptitle("Peak center distribution")
        plt.title(f"Fit failed for {n_failed_fit} pixels ({n_failed_fit/max(1,(n_pix-1)):.2%})")
        plt.legend()
        plt.grid()
        pdf.savefig(); plt.clf()

        # Peak mu distribution (zoomed in)
        for fc, lc, name in FRONTENDS:
            plt.hist(mus[fc:lc+1,:].reshape(-1), bins=64, range=[16, 32],
                     histtype='step', label=name, rasterized=True)
        plt.xlabel("Peak $\\mu$ [25 ns]")
        plt.ylabel("Pixels / bin")
        plt.suptitle("Peak center distribution")
        plt.title(f"Fit failed for {n_failed_fit} pixels ({n_failed_fit/max(1,(n_pix-1)):.2%})")
        plt.legend()
        plt.grid()
        pdf.savefig(); plt.clf()

        # Peak sigma distribution
        for fc, lc, name in FRONTENDS:
            plt.hist(sigmas[fc:lc+1,:].reshape(-1), bins=64, range=[0, 2],
                     histtype='step', label=name, rasterized=True)
        plt.xlabel("Peak $\\sigma$ [25 ns]")
        plt.ylabel("Pixels / bin")
        plt.suptitle("Peak width distribution")
        plt.title(f"Fit failed for {n_failed_fit} pixels ({n_failed_fit/max(1,(n_pix-1)):.2%})")
        plt.legend()
        plt.grid()
        pdf.savefig(); plt.clf()

        plt.close()

        # Save some stuff
        np.savez_compressed(os.path.splitext(output_file)[0] + ".npz",
            mus=mus, sigmas=sigmas)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "input_file", nargs="*",
        help="The _source_scan_interpreted.h5 file(s). If not given, looks in output_data/module_0/chip_0.")
    parser.add_argument("-f", "--overwrite", action="store_true",
                        help="Overwrite plots when already present.")
    parser.add_argument("--pixels", nargs=4, default=[0, -1, 0, -1], type=int,
                        metavar=("FIRST_COL", "LAST_COL", "FIRST_ROW", "LAST_ROW"),
                        help="Fit peak on single pixels' spectra. Last row/col are included.")
    parser.add_argument("-j", "--join", metavar="OUTPUT_FILE.PDF", default=None,
                        help="Join all input files and put results in the given PDF.")
    args = parser.parse_args()

    files = []
    if args.input_file:  # If anything was given on the command line
        for pattern in args.input_file:
            files.extend(glob.glob(pattern, recursive=True))
    else:
        files.extend(glob.glob("output_data/module_0/chip_0/*_source_scan_interpreted.h5"))
    files.sort()

    if args.join is None:
        for fp in tqdm(files):
            try:
                main([fp], args.overwrite, args.pixels)
            except Exception:
                print(traceback.format_exc())
    else:
        main(files, args.overwrite, args.pixels, args.join)
